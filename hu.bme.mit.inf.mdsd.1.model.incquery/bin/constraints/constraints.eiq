package constraints

import "http://model/1.0"

//Based on model

/**
 * A kapitány a csapat tagja
 */
@Constraint(
	location = Team,
	severity = "error",
	message = "$Team$'s captain plays in another team."
)
pattern captainIsNotInTheTeam(Team : Team) {
	Team.captain.teamMember(Team, c);
	TeamMember.team(c, Team2);
	Team != Team2;
}

/**
 * A cserék a csapat tagjai
 */
@Constraint(
	location = Sub,
	severity = "error",
	message = "$Sub$ is a substitute in $Team$, but plays in another team."
)
pattern substitutesAreNotInTheTeam(Team : Team, Sub : TeamMember) {
	Team.substitutes.teamMember(Team, Sub);
	TeamMember.team(Sub, Team2);
	Team != Team2;
}

/**
 * A kezdõjátékosok a csapat tagjai
 */
@Constraint(
	location = Starter,
	severity = "error",
	message = "$Starter$ is in the starting line of $Team$, but plays in another team."
)
pattern startingPlayersAreNotInTheTeam(Team : Team, Starter : TeamMember) {
	Team.startingLine.teamMember(Team, Starter);
	TeamMember.team(Starter, Team2);
	Team != Team2;
}

/**
 * A személyzet tagjai ehhez a csapathoz tartoznak
 */
@Constraint(
	location = StaffMember,
	severity = "error",
	message = "$StaffMember$ is in the staff of $Team$, but plays in another team."
)
pattern staffsAreNotInTheTeam(Team : Team, StaffMember : TeamMember) {
	Team.staff.teamMember(Team, StaffMember);
	TeamMember.team(StaffMember, Team2);
	Team != Team2;
}

/**
 * A cserejátékosok között nincs kezdõjátékos, és fordítva
 */
@Constraint(
	location = TeamMember,
	severity = "error",
	message = "$TeamMember$ is  in the starting line and in the substitutes of $Team$ at the same time."
)
pattern startersAndSubstitutes(Team : Team, TeamMember : TeamMember) {
	Team.startingLine.teamMember(Team, TeamMember);
	Team.substitutes.teamMember(Team, TeamMember);
}

/**
 * Senki se szerepel kétszer egy kapcsolaton belül a csapatnál
 */
@Constraint(
	location = Starter,
	severity = "error",
	message = "$Starter$ is already in the starting line of $Team$."
)
pattern startersAreTwice(Team : Team, Starter : TeamMember) {
	Team.startingLine.teamMember(Team, Starter);
	Team.startingLine.teamMember(Team, other);
	Starter == other;
}

@Constraint(
	location = Sub,
	severity = "error",
	message = "$Sub$ is already in the substitutes of $Team$."
)
pattern subsAreTwice(Team : Team, Sub : TeamMember) {
	Team.staff.teamMember(Team, Sub);
	Team.staff.teamMember(Team, other);
	Sub == other;
}

@Constraint(
	location = StaffMember,
	severity = "error",
	message = "$StaffMember$ is already in the staff of $Team$."
)
pattern staffsAreTwice(Team : Team, StaffMember : TeamMember) {
	Team.staff.teamMember(Team, StaffMember);
	Team.staff.teamMember(Team, other);
	StaffMember == other;
}

/**
 * Minden csapattag a csapatában cserejátékos vagy kezdõjátékos és/vagy személyzeti tag
 */
@Constraint(
	location = TeamMember,
	severity = "error",
	message = "$TeamMember$ is in the $Team$, but doesn't have any role."
)
pattern teamMemberHasNoRoleInTeam(Team : Team, TeamMember : TeamMember) {
	TeamMember.team(TeamMember, Team);
	neg find teamMemberHasRoleInTeam(Team, TeamMember);
}

private pattern teamMemberHasRoleInTeam(Team : Team, TeamMember : TeamMember) {
	Team.startingLine.teamMember(Team,TeamMember);
} or {
	Team.substitutes.teamMember(Team,TeamMember);
} or {
	Team.staff.teamMember(Team,TeamMember);
}


//Based on rules

/**
 * A csapatok nevei egyediek
 */
@Constraint(
	location = Team,
	severity = "error",
	message = "$Team$ doesn't have a unique name."
)
pattern notUniqueTeamNames(Team : Team) {
	Team.name(Team, name1);
	Team.name(team2, name2);
	Team != team2;
	name1 == name2;
}

/**
 * A kezdõjátékosok között pontosan 1 kapus és 4 mezõnyjátékos van
 */
@Constraint(
	location = Team,
	severity = "error",
	message = "$Team$'s starting line is not valid."
)
pattern startingLineCombination(Team : Team) {
	M == count find constraints.goalkeepersInStartingLine(Team, _);
	N == count find constraints.fieldplayersInStartingLine(Team, _);
	check (	(M as Integer) == 1	);
	check (	(N as Integer) == 4	);
}

private pattern goalkeepersInStartingLine(Team : Team, Gk : TeamMember) {
	Team.startingLine.teamMember(Team, Gk);
	Player.teamMember(player, Gk);
	Player.position(player, ::Goalkeeper);
}

private pattern fieldplayersInStartingLine(Team : Team, Pl : TeamMember) {
	Team.startingLine.teamMember(Team, Pl);
	Player.teamMember(player, Pl);
	Player.position(player, ::FieldPlayer);
}

/**
 * Minden csapattagnak egyedi azonosítója van függetlenül a csapattól
 */
@Constraint(
	location = TeamMember,
	severity = "error",
	message = "$TeamMember$ doesn't have a unique id."
)
pattern notUniqueId(TeamMember : TeamMember) {
	TeamMember.id(TeamMember, id1);
	TeamMember.id(t2, id2);
	
	t2 != TeamMember;
	id1 == id2;
}

/**
 * Minden csapattagnak max 1 piroslapja lehet
 */
@Constraint(
	location = TeamMember,
	severity = "error",
	message = "$TeamMember$ has more than one red card."
)
pattern moreRedCards(TeamMember : TeamMember) {
	M == count find redCards(TeamMember);
	check((M as Integer) > 1);
}

private pattern redCards(TeamMember : TeamMember) {
	Event.committer(e, TeamMember);
	Event.type(e, ::RedCard);
} or {
	Event.committer(e, TeamMember);
	Event.type(e, ::RedCardWithBan);
}

/**
 * Minden játékosnak max 1 sárgalapja lehet
 */
@Constraint(
	location = TeamMember,
	severity = "error",
	message = "$TeamMember$ has more than one yellow card."
)
pattern moreYellowCards(TeamMember : TeamMember) {
	M == count find yellowCards(TeamMember);
	check((M as Integer) > 1);
}

private pattern yellowCards(TeamMember : TeamMember) {
	Event.committer(e, TeamMember);
	Event.type(e, ::YellowCard);
}

/**
 * Minden játékosnak egyedi mezszáma van a csapaton belül
 */
@Constraint(
	location = TeamMember,
	severity = "error",
	message = "$TeamMember$ has not a unique shirt number in $Team$"
)
pattern notUniqueShirtNo(TeamMember : TeamMember, Team : Team) {
	TeamMember.playerRole(TeamMember, pl1);
	TeamMember.playerRole(_, pl2);
	Player.teamMember.team(pl1, Team);
	Player.teamMember.team(pl2, Team);
	Player.shirtNo(pl1, s1);
	Player.shirtNo(pl2, s2);
	
	pl1 != pl2;
	s1 == s2;
}

/**
 * Csak játékosnak lehet gólja, sárgalapja és RedCardWithBan (piroslapja mindenkinek lehet)
 */
@Constraint(
	location = TeamMember,
	severity = "error",
	message = "$TeamMember$ has illegal event in $Team$"
)
pattern teamMemberHasIllegalEvent(TeamMember : TeamMember, Team : Team) {
	TeamMember.team(TeamMember, Team);
	find playerEvents(TeamMember, Team);
	neg find checkPlayerMember(TeamMember);	
}

private pattern checkPlayerMember(TeamMember : TeamMember) {
	Player.teamMember(_, TeamMember);
}

private pattern playerEvents(TeamMember : TeamMember, Team : Team) {
	TeamMember.team(TeamMember, Team);
	Event.committer(e, TeamMember);
	Event.type(e, ::Goal);
} or {
	TeamMember.team(TeamMember, Team);
	Event.committer(e, TeamMember);
	Event.type(e, ::YellowCard);	
} or {
	TeamMember.team(TeamMember, Team);
	Event.committer(e, TeamMember);
	Event.type(e, ::RedCardWithBan);
}

/**
 * Egy csapatnál bármely 3 RedCardWithBan típusú esemény sem lehet 2 percen belül (nem lehetnek a pályán 2+1-nél kevesebben)
 */
@Constraint(
	location = Team,
	severity = "error",
	message = "$Team$ has two much 2 minutes ban in short period"
)
pattern tooMuchBan(Team : Team) {
	Event.type(e1, ::RedCardWithBan);
	Event.type(e2, ::RedCardWithBan);
	Event.type(e3, ::RedCardWithBan);
	
	Event.committer.team(e1, Team);
	Event.committer.team(e2, Team);
	Event.committer.team(e3, Team);	
	
	Event.time(e1, t1);
	Event.time(e2, t2);
	Event.time(e3, t3);
	
	check(t1 > t2);
	check(t2 > t3);
	check((t1 - t3) < 120);
} 

/**
 * A két csapat bünetõinek a száma csak eggyel térhet el
 */
@Constraint(
	location = Match,
	severity = "error",
	message = "There is too big difference between the shot penalties."
)
pattern tooMuchDiffAnyPenalties(Match : Match) {	
	Match.Home(Match, team1);
	Match.Visitor(Match, team2);
	
	M == count find teamPenalties(team1);
	N == count find teamPenalties(team2);
	
	check((N - M) > 1);
}

private pattern teamPenalties(Team : Team) {
	Team.penalties(Team, _);
}

/**
 * Ezekben az esetekben már korábben vége kellett volna térjen a párharc.
 */
@Constraint(
	location = Match,
	severity = "error",
	message = "asd"
)
pattern tooMuchDiffSuccessPenalties(Match : Match) {
	Match.Home(Match, team1);
	Match.Visitor(Match, team2);
	
	S1 == count find successPenalties(team1);
	S2 == count find successPenalties(team2);
	
	T1 == count find teamPenalties(team1);
	T2 == count find teamPenalties(team2);
	
	check(T1 == 3);
	check(T2 == 3);
	check(S1 == 3);
	check(S2 == 0); 
	
} or {
	Match.Home(Match, team1);
	Match.Visitor(Match, team2);
		
	S1 == count find successPenalties(team1);
	S2 == count find successPenalties(team2);
	
	T1 == count find teamPenalties(team1);
	T2 == count find teamPenalties(team2);
	
	check(T1 == 4);
	check(T2 == 4);
	check(S1 == 3);
	check(S2 <= 1); 

} or {
	Match.Home(Match, team1);
	Match.Visitor(Match, team2);
		
	S1 == count find successPenalties(team1);
	S2 == count find successPenalties(team2);
	
	T1 == count find teamPenalties(team1);
	T2 == count find teamPenalties(team2);
	
	check(T1 == 5);
	check(T2 == 5);
	check(S1 == 3);
	check(S2 <= 2); 

} or {
	Match.Home(Match, team1);
	Match.Visitor(Match, team2);
	
	S1 == count find successPenalties(team1);
	S2 == count find successPenalties(team2);
	
	T1 == count find teamPenalties(team1);
	T2 == count find teamPenalties(team2);
	
	check(T1 == 4);
	check(T2 == 4);
	check(S1 == 4);
	check(S2 <= 1); 
} or {
	Match.Home(Match, team1);
	Match.Visitor(Match, team2);
	
	S1 == count find successPenalties(team1);
	S2 == count find successPenalties(team2);
	
	T1 == count find teamPenalties(team1);
	T2 == count find teamPenalties(team2);
	
	check(T1 == 5);
	check(T2 == 5);
	check(S1 == 4);
	check(S2 <= 2); 

}  or {
	Match.Home(Match, team1);
	Match.Visitor(Match, team2);
	
	S1 == count find successPenalties(team1);
	S2 == count find successPenalties(team2);
	
	T1 == count find teamPenalties(team1);
	T2 == count find teamPenalties(team2);
	
	check(T1 == 5);
	check(T2 == 5);
	check(S1 == 5);
	check(S2 <= 3); 

}  or {
	Match.Home(Match, team1);
	Match.Visitor(Match, team2);
	
	S1 == count find successPenalties(team1);
	S2 == count find successPenalties(team2);
	
	T1 == count find teamPenalties(team1);
	T2 == count find teamPenalties(team2);
	
	check(T1 == T2);
	check(T1 > 5);
	check(T2 > 5);
	check(S1-S2 > 1);
}

private pattern successPenalties(Team : Team) {
	Team.penalties(Team, p);
	Penalty.isSuccess(p, true);
}

@Constraint(
	location = Person,
	severity = "error",
	message = "$Person$ cannot be TeamMember, because he/she is the referee"
)
pattern refereeNotPerson(Person : Person) {
	TeamMember(Person);
	Match.Referee(_,Person);
}

@Constraint(
	location = Person,
	severity = "error",
	message = "$Person$ cannot be TeamMember, because he/she is the assistant"
)
pattern assistantNotPerson(Person : Person) {
	TeamMember(Person);
	Match.Assistant(_,Person);
}

@Constraint(
	location = Person,
	severity = "error",
	message = "$Person$ cannot be TeamMember, because he/she is the third referee"
)
pattern thirdRefereeNotPerson(Person : Person) {
	TeamMember(Person);
	Match.ThirdReferee(_,Person);
}

@Constraint(
	location = Person,
	severity = "error",
	message = "$Person$ cannot be TeamMember, because he/she is the supervisor"
)
pattern supervisorNotPerson(Person : Person) {
	TeamMember(Person);
	Match.Supervisor(_,Person);
}
